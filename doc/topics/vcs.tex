\section{Versioning Control Systems}

% what

% git focus: there are many cvs's, git is part of a "new" generation and by far the most popular of those, unless you have a good reason you should use git for every new project
Over the years, there has been many versioning control systems in use. CVS\idx{CVS} has critical issues and should absolutely not be used today. It was superceded by subversion\idx{Subversion} (SVN) that fixed all those issues. After subversion came a new generation of \textsl{distributed} versioning control systems (e.g., GIT, mercurial\idx{Mercurial} and monotone\idx{Monotone}). Among these, GIT\idx{GIT} is by far the most popular one. Unless you have a really good reason you should use GIT for every new project. And for that reason, GIT is what is being covered here. A good reference is the "Pro GIT" book\cite{progit}.

\subsection{Diffs}

See figure \ref{topics:vcs:diff}.

\begin{figure}[tbp]
  \vspace{10mm}
  \begin{tikzpicture}[remember picture, overlay]
    % variables
    \newcommand{\spacing}[0]{4mm}
    
    \coordinate (origo) at (40mm,0);
    
    % styles
    \tikzstyle{file}  = [
      rectangle,
      draw,
      anchor=west,
      align=left,
      scale=0.71,
    ]
    
    \node[file,rounded corners,draw=teal,fill=teal!20] (diff) at (origo) {
        \texttt{3c3}\\
        \texttt{< I hope you are doing wel.}\\
        \texttt{---}\\
        \texttt{> I hope you are doing well.}
    };
    \draw[draw=teal] (diff.south) -- ([yshift=-\spacing] diff.south);
    \draw[->,>=stealth,draw=teal] ([xshift=-\spacing,yshift=-\spacing] diff.south west) -- ([xshift=\spacing,yshift=-\spacing] diff.south east);
    
    \node[file, anchor=east] (input) at ([xshift=-\spacing,yshift=-\spacing] diff.south west) {
      \small
      \texttt{Hello Mom,}\\
      \texttt{}\\
      \texttt{I hope you are doing wel.}\\
      \texttt{}\\
      \texttt{Best,}\\
      \texttt{Billie}
    };
    \node[file, anchor=west] (output) at ([xshift=\spacing,yshift=-\spacing] diff.south east) {
      \small
      \texttt{Hello Mom,}\\
      \texttt{}\\
      \texttt{I hope you are doing well.}\\
      \texttt{}\\
      \texttt{Best,}\\
      \texttt{Billie}
    };
  \end{tikzpicture}
  \vspace{22mm}
  
  \caption{Coding of the difference between two revisions of the same file.}
  \label{topics:vcs:diff}
\end{figure}

\subsection{Commit Logs}

\subsubsection{State Machine}

% go through figure
Each file in a repository is in one of four states. We essentially have a $filename \mapsto state$ mapping. The set of available GIT operations depends on the state, and some of these update the mapping. Figure \ref{topics:vcs:file:status} provides an overview. Any newly created file is \textsl{untracked}\idx{Untracked}. This means that GIT doesn't concern itself with it. Autogenerated files (e.g., logs and outputs) should generally stay in this state. Otherwise they will cause trouble when merging (see section \ref{topics:vcs:merging}). Source code and documentation are examples of files that benefit from being under version control. In GIT parlance, we say that we need to \textsl{track} them. This is what GITs \textsl{add} command does. Any tracked file can be \textsl{untracked} using the GITs \textsl{remove} command. When a file is added it transitions to the \textsl{staged}\idx{Staged} state. This means that the next commit (by default) should store a snapshot of it, and thus transition the file to the \textsl{committed}\idx{Comitted} state. All files in this state are defined by not having changed since their last commit. When they change (e.g., by a human or a machine modifying it on disk), they automatically transition into the \textsl{modified}\idx{Modified} state. Before committing the changes they need to be \textsl{staged} using the \textsl{stage} command. This transitions the files to the \textsl{staged} state (that we have covered). This is a selection mechanism that allows you to only commit a subset of the modified files.

\begin{figure}[tbp]
  \begin{tikzpicture}[]
    % variables
    \newcommand{\spacing}[0]{20mm}
    \newcommand{\statesize}[0]{20mm}
    \newcommand{\radius}[0]{24mm}
    \newcommand{\groupsize}[0]{(2*\radius+\statesize+\spacing/2)}
    
    \coordinate (origo) at (80mm,-\spacing-1.5*\statesize);
    
    % styles
    \tikzstyle{state}  = [
      circle,
      draw,
      anchor=center,
      align=left,
      minimum width=\statesize,
      scale=1.0,
    ]
    \tikzstyle{group}  = [
      rectangle,
      draw=purple,
      rounded corners,
      fill=purple!10!white,
      anchor=center,
      minimum width=\groupsize,
      minimum height=\groupsize,
      scale=1.0,
    ]
    \tikzstyle{arrow}  = [
      ->,
      >=stealth,
      draw,
    ]
    
    \node[group] (group) at (origo) {};
    \node[text=purple] (grouplabel) at ([yshift=-0.5*\spacing] group.north) {tracked};
    
    \node[state] (staged)    at ([xshift=-0.8660254037844387*\radius, yshift=0.49999999999999994*\radius] origo) {staged};
    \node[state] (committed)  at ([xshift=0.8660254037844387*\radius, yshift=0.49999999999999994*\radius] origo) {committed};
    \node[state] (modified)  at ([yshift=-\radius] origo) {modified};
    \node[state, anchor=east] (untracked) at ([xshift=-1.5*\spacing] staged.west) {untracked};
    
    \draw[arrow] (untracked) -- (staged) node[midway,sloped,above] {add};
    \draw[arrow] (staged) -- (committed) node[midway,sloped,above] {commit};
    \draw[arrow] (committed) -- (modified) node[midway,sloped,above] {edit};
    \draw[arrow] (modified) -- (staged) node[midway,sloped,above] {stage};
    \draw[arrow,draw=purple,text=purple] ([yshift=-1/6*\groupsize] group.west) -- (untracked) node[midway,sloped,above] {remove};
  \end{tikzpicture}
  \caption{File status lifecycle in GIT.}
  \label{topics:vcs:file:status}
\end{figure}

% stage and commit
The commit command has an option for listing the specific files that you want to commit. This essentially produces a temporary stage and then commits that stage. Files that were already staged will transition to the committed state.

% typical workflow
A typical workflow for implementing a change involves:
\begin{enumerate}
  \descitem{Update} Modify committed files and add new (and thus untracked) files.
  \descitem{Select} Select files whose changes represent a \quoted{unit} of change. This is usually all the updated files, but not always. Good qualities of a unit of change is that
    \begin{itemize}
      \item It can be described briefly and succinctly.
      \item It represents a change that is easy to reasons about. It being easy to reason about means that you can easily think about the codebase both with and without the change (even if you have multiple later commits). This allows you to later remove that commit from the timeline of the codebase with confidence, should it turn out to have negative sideeffects.
    \end{itemize}
  \descitem{Commit} Commit the selected files.
\end{enumerate}

\subsubsection{Status}

\subsection{Branches}

\subsection{Merging}
\label{topics:vcs:merging}

